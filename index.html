<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Interactive Sound Gallery</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #ffffff; color: rgb(46, 44, 44); font-family: sans-serif; text-align: center; }
    .game-screen {
      display: none;
      min-height: 100vh;
      width: 100%;
      justify-content: flex-start;
      align-items: center;
      flex-direction: column;
      overflow: hidden;
      touch-action: none;
      overscroll-behavior: none;
      margin-top: 1px;
      position: relative;
    }
    #upload-screen {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }
    #menu {
      min-height: 100vh;
      display: none;
      flex-direction: column;
      justify-content: space-evenly;
      align-items: center;
      padding: 20px;
    }
    button { margin: 10px; padding: 20px; font-size: 20px; cursor: pointer; }
    canvas {
      border: 1px solid black;
      width: 100vw;
      max-width: 500px;
      aspect-ratio: 500 / 888;
      display: block;
      margin: 0 auto;
    }
    video { display: none; }
    .image-button {
      background: none;
      border: none;
      padding: 0;
      margin: 10px;
      cursor: pointer;
    }
    .image-button img {
      width: 80vw;
      max-width: 400px;
      height: auto;
      border-radius: 16px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      cursor: pointer;
    }
    .image-button:hover img {
      transform: scale(1.03);
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
    }
    .image-button:active img {
      transform: scale(0.96);
      opacity: 0.8;
    }
    .back-button {
      border-radius: 12px;
      font-weight: bold;
      margin-top: 1px;
      padding: 6px 12px;
      font-size: 16px;
      background-color: #333;
      color: white;
      border: none;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      transition: all 0.2s ease;
      user-select: none;
      justify-content: flex-start;
    }
    .back-button:hover {
      transform: scale(1.03);
      background-color: #444;
    }
    .upload-container {
      width: 90vw;
      max-width: 500px;
      background: #f5f5f5;
      padding: 30px;
      border-radius: 16px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    .upload-container h1 {
      margin-bottom: 20px;
      font-size: 28px;
    }
    .file-input-wrapper {
      position: relative;
      margin: 20px 0;
    }
    .file-input-wrapper input[type="file"] {
      display: none;
    }
    .file-input-label {
      display: block;
      padding: 15px 30px;
      background-color: #4CAF50;
      color: white;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 18px;
    }
    .file-input-label:hover {
      background-color: #45a049;
      transform: scale(1.02);
    }
    .file-name {
      margin-top: 10px;
      font-size: 14px;
      color: #666;
      min-height: 20px;
    }
    .sample-button {
      margin-top: 30px;
      padding: 12px 24px;
      background-color: #2196F3;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    .sample-button:hover {
      background-color: #0b7dda;
      transform: scale(1.02);
    }
    .error-message {
      color: #f44336;
      margin-top: 10px;
      font-size: 14px;
      min-height: 20px;
    }
    .info-text {
      margin-top: 15px;
      font-size: 14px;
      color: #666;
      line-height: 1.6;
    }
    .loading-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      z-index: 9999;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }
    .loading-spinner {
      border: 8px solid #f3f3f3;
      border-top: 8px solid #3498db;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      animation: spin 1s linear infinite;
    }
    .loading-text {
      color: white;
      margin-top: 20px;
      font-size: 18px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <!-- アップロード画面（トップページ） -->
  <div id="upload-screen">
    <div class="upload-container">
      <h1>Views</h1>
      <p class="info-text">風景動画をアップロードして、音で遊んでみましょう</p>
      
      <div class="file-input-wrapper">
        <input type="file" id="videoUpload" accept="video/*" />
        <label for="videoUpload" class="file-input-label">動画を選択</label>
        <div class="file-name" id="fileName"></div>
      </div>
      
      <div class="error-message" id="errorMessage"></div>
      
      <div class="info-text">
        <strong>条件:</strong><br>
        ・解像度: 1080×1920<br>
        ・長さ: 1分30秒以内
      </div>
      
      <button class="sample-button" onclick="showSamples()">サンプルを見る</button>
    </div>
  </div>

  <!-- ローディング画面 -->
  <div id="loadingOverlay" class="loading-overlay">
    <div class="loading-spinner"></div>
    <div class="loading-text">処理中...</div>
  </div>

  <!-- サンプルメニュー -->
  <div id="menu">
    <h1>Views</h1>

    <button id="swissBtn" class="image-button">
      <img src="assets/image/schwarzsee_and_ober_gabelhorn_m.jpg" alt="マッターホルン" />
    </button>

    <button id="brazilBtn" class="image-button">
      <img src="assets/image/museum_of_tomorrow_2_m.jpg" alt="明日の博物館" />
    </button>

    <button id="singapBtn" class="image-button">
      <img src="assets/image/singapore_at_night_2_m.jpg" alt="シンガポール" />
    </button>

    <button class="back-button" onclick="goBackToUpload()">戻る</button>
  </div>

  <!-- ゲーム画面 -->
  <div id="game" class="game-screen">
    <canvas id="gameCanvas" width="500" height="888"></canvas>
    <button class="back-button" onclick="goBack()">Back</button>
    <video id="gameVideo" muted></video>
  </div>

  <script type="module">
    const configs = [
      {
        videoSrc: 'assets/scene/switzerland_tiktok.mp4',
        segURL: 'db/Segmentation/switzerland_S.json',
        depURL: 'db/Depth/switzerland_D.json',
        bgmURL: 'assets/bgm/switzerland_tiktok.mp3',
      },
      {
        videoSrc: 'assets/scene/brazil58_tiktok.mp4',
        segURL: 'db/Segmentation/brazil58_S.json',
        depURL: 'db/Depth/brazil58_D.json',
        bgmURL: 'assets/bgm/brazil58_tiktok.mp3',
      },
      {
        videoSrc: 'assets/scene/singapore40_tiktok.mp4',
        segURL: 'db/Segmentation/singapore40_S.json',
        depURL: 'db/Depth/singapore40_D.json',
        bgmURL: 'assets/bgm/singapore40_tiktok.mp3',
      }
    ];

    // ADE20K クラスラベル
    const ADE20K_CLASSES = [
        "wall", "building", "sky", "floor", "tree", "ceiling", "road", "bed",
        "window", "grass", "cabinet", "sidewalk", "person", "earth", "door", "table",
        "mountain", "plant", "curtain", "chair", "car", "water", "painting", "sofa",
        "shelf", "house", "sea", "mirror", "rug", "field", "armchair", "seat", "fence",
        "desk", "rock", "wardrobe", "lamp", "bathtub", "railing", "cushion", "base",
        "box", "column", "sign", "chest", "counter", "sand", "sink", "skyscraper",
        "fireplace", "refrigerator", "grandstand", "path", "stairs", "runway", "case",
        "pool", "pillow", "screen door", "stairway", "river", "bridge", "bookcase",
        "blind", "coffee table", "toilet", "flower", "book", "hill", "bench",
        "countertop", "stove", "palm", "kitchen island", "computer", "swivel chair",
        "boat", "bar", "arcade machine", "hovel", "bus", "towel", "light", "truck",
        "tower", "chandelier", "awning", "streetlight", "booth", "television receiver",
        "airplane", "dirt", "apparel", "pole", "land", "bannister", "escalator",
        "ottoman", "bottle", "buffet", "poster", "stage", "van", "ship", "fountain",
        "conveyer belt", "canopy", "washer", "plaything", "swimming pool", "stool",
        "barrel", "basket", "waterfall", "tent", "bag", "minibike", "cradle",
        "oven", "ball", "food", "step", "tank", "trade name", "microwave", "pot",
        "animal", "bicycle", "lake", "dishwasher", "screen", "blanket", "sculpture",
        "hood", "sconce", "vase", "traffic light", "tray", "trash can", "fan",
        "pier", "crt screen", "plate", "monitor", "bulletin board", "shower",
        "radiator", "glass", "clock", "flag"
    ];

    const segSounds = {
      0: [new Audio('assets/sound/grass_sound.mp3')],
      1: [new Audio('assets/sound/building_sound.mp3')],
      2: [new Audio('assets/sound/sky_sound.mp3')],
      13: [new Audio('assets/sound/earth_sound.mp3')],
      16: [new Audio('assets/sound/mountain_sound.mp3')],
      21: [new Audio('assets/sound/water_sound1.mp3'), new Audio('assets/sound/water_sound2.mp3'), new Audio('assets/sound/water_sound3.mp3'), new Audio('assets/sound/water_sound4.mp3'), new Audio('assets/sound/water_sound5.mp3')],
      26: [new Audio('assets/sound/water_sound1.mp3')],
      34: [new Audio('assets/sound/rock_sound.mp3')],
      61: [new Audio('assets/sound/bridge_sound.mp3')],
      76: [new Audio('assets/sound/building_sound.mp3')],
      86: [new Audio('assets/sound/building_sound.mp3')],
      94: [new Audio('assets/sound/grass_sound.mp3')],
      140: [new Audio('assets/sound/grass_sound.mp3')],
    };

    const segDrag = {
      0: new Audio('assets/sound/grass_sound.mp3'),
      1: new Audio('assets/drag/building_drag.mp3'),
      2: new Audio('assets/drag/sky_drag.mp3'),
      13: new Audio('assets/drag/earth_drag.mp3'),
      16: new Audio('assets/drag/mountain_drag.mp3'),
      21: new Audio('assets/drag/water_drag.mp3'),
      26: new Audio('assets/drag/sea_drag.mp3'),
      34: new Audio('assets/drag/rock_drag.mp3'),
      61: new Audio('assets/drag/building_drag.mp3'),
      76: new Audio('assets/drag/building_drag.mp3'),
      86: new Audio('assets/drag/building_drag.mp3'),
      94: new Audio('assets/sound/grass_sound.mp3'),
      140: new Audio('assets/sound/grass_sound.mp3'),
    };

    const vibrationPatterns = {
      grass: [10, 5, 10, 5],
      mountain: [100, 50, 100],
      water: [20, 20, 20, 20],
      sky: [5, 50],
      building: [10, 20, 40, 80]
    };

    const vibrationIntervals = {
      grass: 600,
      mountain: 1000,
      water: 200,
      sky: 100,
      building: 800
    };

    const SPARKLE_LIFETIME = 15;
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const video = document.getElementById('gameVideo');
    let currentBgm = null;
    let animationId = null;
    let segmentationMap = [], depthMap = [], sparklePoints = [];
    let vibrationIntervalId = null;
    let uploadedVideoURL = null;

    // RenderにホストされているAPIのURL（実際のURLに置き換えてください）
    const API_BASE_URL = 'https://prototype-backend-yc2s.onrender.com';

    // 動画アップロード処理
    document.getElementById('videoUpload').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      document.getElementById('fileName').textContent = file.name;
      document.getElementById('errorMessage').textContent = '';

      // 動画の検証
      const videoElement = document.createElement('video');
      videoElement.preload = 'metadata';

      videoElement.onloadedmetadata = async () => {
        window.URL.revokeObjectURL(videoElement.src);

        const width = videoElement.videoWidth;
        const height = videoElement.videoHeight;
        const duration = videoElement.duration;

        // 解像度と長さのチェック
        if (width !== 1080 || height !== 1920) {
          document.getElementById('errorMessage').textContent = 
            `エラー: 解像度が1080×1920ではありません（現在: ${width}×${height}）`;
          return;
        }

        if (duration > 90) {
          document.getElementById('errorMessage').textContent = 
            `エラー: 動画の長さが1分30秒を超えています（現在: ${Math.floor(duration)}秒）`;
          return;
        }

        // 検証OK - 最初のフレームを抽出してAPIに送信
        await processVideo(file);
      };

      videoElement.src = URL.createObjectURL(file);
    });

    async function processVideo(videoFile) {
      const loadingOverlay = document.getElementById('loadingOverlay');
      loadingOverlay.style.display = 'flex';

      try {
        // 動画の最初のフレームを画像として抽出
        const firstFrameBlob = await extractFirstFrame(videoFile);

        // APIに画像を送信
        const formData = new FormData();
        formData.append('image', firstFrameBlob, 'frame.jpg');

        const response = await fetch(`${API_BASE_URL}/process`, {
          method: 'POST',
          body: formData
        });

        if (!response.ok) {
          throw new Error('API処理に失敗しました');
        }

        const result = await response.json();
        
        // 結果を保存
        segmentationMap = result.segmentation;
        depthMap = result.depth;

        // 動画のURLを保存
        uploadedVideoURL = URL.createObjectURL(videoFile);

        // ゲーム画面に遷移
        loadingOverlay.style.display = 'none';
        startCustomGame();

      } catch (error) {
        loadingOverlay.style.display = 'none';
        document.getElementById('errorMessage').textContent = 
          `エラー: ${error.message}`;
        console.error('処理エラー:', error);
      }
    }

    async function extractFirstFrame(videoFile) {
      return new Promise((resolve, reject) => {
        const videoElement = document.createElement('video');
        const canvasElement = document.createElement('canvas');
        const ctx = canvasElement.getContext('2d');

        videoElement.onloadeddata = () => {
          canvasElement.width = videoElement.videoWidth;
          canvasElement.height = videoElement.videoHeight;
          ctx.drawImage(videoElement, 0, 0);

          canvasElement.toBlob((blob) => {
            window.URL.revokeObjectURL(videoElement.src);
            resolve(blob);
          }, 'image/jpeg', 0.95);
        };

        videoElement.onerror = () => {
          reject(new Error('動画の読み込みに失敗しました'));
        };

        videoElement.src = URL.createObjectURL(videoFile);
      });
    }

    async function startCustomGame() {
      document.getElementById('upload-screen').style.display = 'none';
      document.getElementById('game').style.display = 'flex';
      window.scrollTo({ top: 0, behavior: 'smooth' });

      // BGMなし（アップロードされた動画用）
      if (currentBgm) {
        currentBgm.pause();
        currentBgm.currentTime = 0;
        currentBgm = null;
      }

      // アップロードされた動画を再生
      video.src = uploadedVideoURL;
      video.play();

      sparklePoints = [];

      function draw() {
        ctx.drawImage(video, 0, 0, 500, 888);
        drawSparkles();
        animationId = requestAnimationFrame(draw);
      }
      draw();
    }

    async function startGame(index) {
      document.getElementById('menu').style.display = 'none';
      document.getElementById('game').style.display = 'flex';
      window.scrollTo({ top: 0, behavior: 'smooth' });

      const config = configs[index];

      if (currentBgm) {
        currentBgm.pause();
        currentBgm.currentTime = 0;
      }
      currentBgm = new Audio(config.bgmURL);
      currentBgm.loop = true;
      await currentBgm.play().catch(() => {});

      video.src = config.videoSrc;
      video.play();

      const segRes = await fetch(config.segURL);
      segmentationMap = (await segRes.json()).map;

      const depthRes = await fetch(config.depURL);
      depthMap = (await depthRes.json()).map;

      sparklePoints = [];

      function draw() {
        ctx.drawImage(video, 0, 0, 500, 888);
        drawSparkles();
        animationId = requestAnimationFrame(draw);
      }
      draw();
    }

    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const X = Math.floor(x * 500 / canvas.clientWidth);
      const Y = Math.floor(y * 888 / canvas.clientHeight);
      const scaledX = Math.floor(x * 250 / canvas.clientWidth);
      const scaledY = Math.floor(y * 444 / canvas.clientHeight);
      const segVal = segmentationMap[scaledY]?.[scaledX];
      const depVal = depthMap[scaledY]?.[scaledX];
      if (segVal == null || depVal == null) return;

      const category = getSegmentCategory(segVal);
      if (navigator.vibrate && category && vibrationPatterns[category]) {
        navigator.vibrate(vibrationPatterns[category]);
      }

      sparklePoints.push({ pos: [X, Y], lifetime: SPARKLE_LIFETIME });

      if (segVal in segSounds) {
        const soundArray = segSounds[segVal];
        const randomIndex = Math.floor(Math.random() * soundArray.length);
        const sound = soundArray[randomIndex].cloneNode();
        sound.volume = segVal === 2 ? 1.0 : Math.max(0.1, Math.min(1.0, depVal / 1000));
        sound.play();
      }
    });
    
    function drawSparkles() {
      for (const sparkle of sparklePoints) {
        const { pos, lifetime } = sparkle;
        const alpha = lifetime / SPARKLE_LIFETIME;
        ctx.fillStyle = `rgba(255,255,255,${alpha})`;
        for (let i = 0; i < 10; i++) {
          const offsetX = Math.floor(Math.random() * 11) - 5;
          const offsetY = Math.floor(Math.random() * 11) - 5;
          ctx.beginPath();
          ctx.arc(pos[0] + offsetX, pos[1] + offsetY, 1, 0, Math.PI * 2);
          ctx.fill();
        }
        sparkle.lifetime--;
      }
      sparklePoints = sparklePoints.filter(s => s.lifetime > 0);
    }

    let isDragging = false;
    let currentLoopSound = null;
    let currentLoopSegVal = null;

    canvas.addEventListener('mousedown', (e) => {
      isDragging = true;
      startLoopingSound(e.clientX, e.clientY);
    });

    canvas.addEventListener('mouseup', stopLoopingSound);
    canvas.addEventListener('mouseleave', stopLoopingSound);

    canvas.addEventListener('mousemove', (e) => {
      if (isDragging) {
        updateLoopingSound(e.clientX, e.clientY);
      }
    });

    canvas.addEventListener('touchstart', (e) => {
      isDragging = true;
      const touch = e.touches[0];
      startLoopingSound(touch.clientX, touch.clientY);
    });

    canvas.addEventListener('touchmove', (e) => {
      if (isDragging) {
        const touch = e.touches[0];
        updateLoopingSound(touch.clientX, touch.clientY);
      }
    });

    canvas.addEventListener('touchend', stopLoopingSound);
    canvas.addEventListener('touchcancel', stopLoopingSound);

    function startLoopingSound(clientX, clientY) {
      const { segVal, depVal } = getSegAndDepth(clientX, clientY);
      if (segVal == null || depVal == null || !(segVal in segDrag)) return;

      const category = getSegmentCategory(segVal);
      const interval = vibrationIntervals[category] || 300;
      if (navigator.vibrate && category && vibrationPatterns[category]) {
        clearInterval(vibrationIntervalId);
        const intensityScale = Math.max(0.1, Math.min(1.0, depVal / 1000));
        const basePattern = vibrationPatterns[category];
        const scaledPattern = basePattern.map(ms => Math.round(ms * intensityScale));
        const interval = vibrationIntervals[category] || 300;

        vibrationIntervalId = setInterval(() => {
          navigator.vibrate(scaledPattern);
        }, interval);
      }

      currentLoopSegVal = segVal;

      const sound = segDrag[segVal].cloneNode();
      sound.loop = true;
      sound.volume = segVal === 2 ? 0.5 : Math.max(0.1, Math.min(1.0, depVal / 1000));
      sound.play();
      currentLoopSound = sound;

      const rect = canvas.getBoundingClientRect();
      const x = clientX - rect.left;
      const y = clientY - rect.top;
      const X = Math.floor(x * 500 / canvas.clientWidth);
      const Y = Math.floor(y * 888 / canvas.clientHeight);
      sparklePoints.push({ pos: [X, Y], lifetime: SPARKLE_LIFETIME });
    }

    function updateLoopingSound(clientX, clientY) {
      const { segVal, depVal } = getSegAndDepth(clientX, clientY);
      if (segVal == null || depVal == null || !(segVal in segDrag)) return;

      if (segVal === currentLoopSegVal) {
        if (currentLoopSound && !currentLoopSound.paused) {
          currentLoopSound.volume = segVal === 2 ? 1.0 : Math.max(0.1, Math.min(1.0, depVal / 1000));
        }
        return;
      }

      if (currentLoopSound) {
        currentLoopSound.pause();
        currentLoopSound.currentTime = 0;
        currentLoopSound = null;
      }
      currentLoopSegVal = null;
      clearInterval(vibrationIntervalId);
      startLoopingSound(clientX, clientY);
      console.log("Seg:", segVal, "|", ADE20K_CLASSES[segVal]);
    }

    function stopLoopingSound() {
      isDragging = false;
      if (currentLoopSound) {
        currentLoopSound.pause();
        currentLoopSound.currentTime = 0;
        currentLoopSound = null;
      }
      clearInterval(vibrationIntervalId);
      currentLoopSegVal = null;
    }

    function getSegAndDepth(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const x = clientX - rect.left;
      const y = clientY - rect.top;

      const scaledX = Math.floor(x * 250 / canvas.clientWidth);
      const scaledY = Math.floor(y * 444 / canvas.clientHeight);

      const segVal = segmentationMap[scaledY]?.[scaledX];
      const depVal = depthMap[scaledY]?.[scaledX];

      return { segVal, depVal };
    }

    function goBack() {
      document.getElementById('game').style.display = 'none';
      
      // アップロード動画から戻る場合はアップロード画面へ
      if (uploadedVideoURL) {
        document.getElementById('upload-screen').style.display = 'flex';
        if (uploadedVideoURL) {
          URL.revokeObjectURL(uploadedVideoURL);
          uploadedVideoURL = null;
        }
      } else {
        // サンプルから戻る場合はメニューへ
        document.getElementById('menu').style.display = 'flex';
      }

      if (currentBgm) {
        currentBgm.pause();
        currentBgm.currentTime = 0;
      }

      if (animationId) cancelAnimationFrame(animationId);
      video.pause();
      video.currentTime = 0;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function showSamples() {
      document.getElementById('upload-screen').style.display = 'none';
      document.getElementById('menu').style.display = 'flex';
    }

    function goBackToUpload() {
      document.getElementById('menu').style.display = 'none';
      document.getElementById('upload-screen').style.display = 'flex';
    }

    window.startGame = startGame;
    window.goBack = goBack;
    window.showSamples = showSamples;
    window.goBackToUpload = goBackToUpload;

    document.getElementById('swissBtn').addEventListener('click', () => startGame(0));
    document.getElementById('brazilBtn').addEventListener('click', () => startGame(1));
    document.getElementById('singapBtn').addEventListener('click', () => startGame(2));

    document.addEventListener('DOMContentLoaded', () => {
      document.body.addEventListener('touchstart', unlockAudio, { once: true });
      document.body.addEventListener('click', unlockAudio, { once: true });
    });

    function unlockAudio() {
      Object.values(segSounds).flat().forEach(s => s.play().then(() => s.pause()).catch(() => {}));
      Object.values(segDrag).forEach(s => s.play().then(() => s.pause()).catch(() => {}));
    }

    function getSegmentCategory(segVal) {
      const grassIds = [13];
      const mountainIds = [16];
      const waterIds = [21, 26];
      const skyIds = [2];
      const buildingIds = [1, 76, 86];

      if (grassIds.includes(segVal)) return 'grass';
      if (mountainIds.includes(segVal)) return 'mountain';
      if (waterIds.includes(segVal)) return 'water';
      if (skyIds.includes(segVal)) return 'sky';
      if (buildingIds.includes(segVal)) return 'building';
      return null;
    }
  </script>
</body>
</html>